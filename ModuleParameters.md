# Module Parameters

Module parameters are module-scope declarations that can be overridden by other modules. constants, functions, structs and type aliases can be overridden. They allow a form of genericity and work hand-in-hand with conditional translation.

## Syntax

A module-scope declaration is preceded by the `@param` attribute (TODO or param keyword? choose a syntax) to turn it into a parameter. The initializer (or the function body) is the default value for the parameter, and is mandatory (TODO currently?).

Examples
```
@param const MSAA_SAMPLES = 3;
@param const ENABLE_XYZ = false;
@param alias T = f32;
@param struct Point { x: T, y: T }
@param fn binop(lhs: T, rhs: T) {
	return lhs + rhs;
}
```

The importer module can decide to replace a module parameter with a compatible declaration (see Parameter Compatibility) in the import statement.

Proposed syntax #1
```
import binary_ops<binop: mul_f32>::{reduce_buffer as reduce_mul_f32};
```

Proposed syntax #2
```
import binary_ops with {binop: mul_f32}::{reduce_buffer as reduce_mul_f32};
```

Proposed syntax #3
```
@param(binop: mul_f32)
import binary_ops::{reduce_buffer as reduce_mul_f32};
```

## Parameter Compatibility

A Module Parameter can only be replaced with a compatible declaration. This ensures that any operations using the original declaration stay valid with the replacement declaration.

### Type Compatibility

A type T2 is compatible with a type T1 if one of these conditions is met:

* T1 equals T2
* Transitively, T2 is compatible with T1 if U is compatible with T1 and T2 is compatible with U.
* AbstractInt is compatible with AbstractFloat
* f32 and f16 are compatible with AbstractFloat
* i32 and u32 are compatible with AbstractInt
* T1 and T2 are structs, T1’s fields exist in T2, and are each compatible with T1’s field type. T2 may have additional fields.
* T1 and T2 are generated by the same type-generator (vec, mat, array), and the element type is compatible, and the element count is larger or equal.
* TODO: What about texture types?
* TODO: check what are the built-in function limitations with this compatibility thing. I’m sure there are some.

Examples: TODO

The compatibility criteria for module parameters replacement are as follows:

* constants: a `const` declaration of identical type.
* type aliases: a built-in type, `struct` or `alias` declaration with a compatible type.
structs: a built-in type, `struct` or `alias` declaration with a compatible type.
* function declarations: a `fn` declaration with a compatible signature (user-defined or built-in).
  A function signature is compatible if:
  * It has the same number of parameters
  * The parameter types are compatible with the original function’s parameters. (parameter covariance)
  * If applicable, the original function’s return type is compatible with the replacement function’s return type (return contravariance)
  * If the original function is void, the replacement function may return any type, or void.

Examples: TODO

## Behavior

### Module concretizations

Modules containing parameter declarations are called generic modules. Each usage of a generic module, with different parameters, forms a concretization of the module. Declarations inside different concretizations of the same module are duplicated. (TODO: what happens with declarations that don’t depend on module parameters? var<private> decls? I think they should be duplicated)

NOTE: aliases referring to the same declaration do not produce different concretizations.

NOTE: each module concretization forms a distinct module. Importing multiple concretizations of the same module is allowed. 
Root Module: Shader Parameters
Module parameters defined or published (TODO: publish spec) in the Root Module are called Shader Parameters. Shader Parameters can be set from the host code with a linker-specific API.

NOTE: root module declarations are not reachable from other modules (due to cyclic imports) so shader parameters can only be replaced from the host code. (TODO: should we allow import cycles?)

### Conditional Translation

Changes to the Conditional Translation spec:

* Module parameters of type `bool` can be used as feature flags for conditional translation. (TODO: integer conditionals)
* Conversely, only module parameters can be used for conditional translation. Shader parameters are controlled by the host code.
* The parameter needs to be imported (identifier in scope) to be used in `@if`
* With module concretizations, importer modules can set feature flags of imported modules.
* Typically projects define the feature flags in one module, publish them from the root module, and import them in the modules that need it. (TODO: is importing from the root module allowed?)

## Implementation

The same declaration in different concretizations of a generic module need to be mangled with unique names. (TODO)
